paste(x, collapse = " ")))
b_hat <- optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = counts)$par[2]
res <- c(res, b_hat)
boot_dist <- foreach(
i = 1:B,
.combine = 'c'
) %dopar% {
ll_fct(
counts, dp = F)
}
boot_dists[[i]] <- boot_dist
dp_counts <- counts + gaussian_mech_zCDP_vec(counts, 1, rho/length(counts))
dp_boot_dist <- foreach(
i = 1:B,
.combine = 'c'
) %dopar% {
ll_fct(
dp_counts, dp = T)
}
#dp_boot_dist <- apply(t(replicate(1000, rowSums(rmultinom(sum(tmp_counts), 1, tmp_counts)))), 1, function(x) optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = x)$par[2])
dp_boot_dists[[i]] <- dp_boot_dist
dp_res <- c(dp_res, optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = dp_counts)$par[2])
cat("Iter: ", i, "\n")
}
n_data <- 1000
dp_res <- NULL
res <- NULL
boot_dists <- list()
dp_boot_dists <- list()
B <- 1000
ll_fct <- function(counts, dp = F){
if(dp){
tmp_counts <- counts + gaussian_mech_zCDP_vec(counts, 1, rho/length(counts))
} else {
tmp_counts <- counts
}
samp_counts <- rowSums(rmultinom(sum(tmp_counts), 1, tmp_counts))
optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = samp_counts)$par[2]
}
for(i in 1:1000){
x <- rbinom(n_data, 1, 0.8)
p <- 1 / (1 + exp(-cbind(1, x) %*% betas))
y <- rbinom(n_data, 1, p)
orig_data <- data.frame(y, x)
counts <-
table(apply(orig_data, 1, function(x)
paste(x, collapse = " ")))
b_hat <- optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = counts)$par[2]
res <- c(res, b_hat)
boot_dist <- foreach(
i = 1:B,
.combine = 'c'
) %dopar% {
ll_fct(
counts, dp = F)
}
boot_dists[[i]] <- boot_dist
dp_counts <- counts + gaussian_mech_zCDP_vec(counts, 1, rho/length(counts))
dp_boot_dist <- foreach(
i = 1:B,
.combine = 'c'
) %dopar% {
ll_fct(
dp_counts, dp = T)
}
#dp_boot_dist <- apply(t(replicate(1000, rowSums(rmultinom(sum(tmp_counts), 1, tmp_counts)))), 1, function(x) optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = x)$par[2])
dp_boot_dists[[i]] <- dp_boot_dist
dp_res <- c(dp_res, optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = dp_counts)$par[2])
cat("Iter: ", i, "\n")
}
n_data <- 500
dp_res <- NULL
res <- NULL
boot_dists <- list()
dp_boot_dists <- list()
B <- 1000
ll_fct <- function(counts, dp = F){
if(dp){
tmp_counts <- counts + gaussian_mech_zCDP_vec(counts, 1, rho/length(counts))
if (any(tmp_counts < 0)) {
tmp_counts <- tmp_counts + abs(min(tmp_counts[tmp_counts < 0]))
}
} else {
tmp_counts <- counts
}
samp_counts <- rowSums(rmultinom(sum(tmp_counts), 1, tmp_counts))
optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = samp_counts)$par[2]
}
for(i in 1:1000){
x <- rbinom(n_data, 1, 0.8)
p <- 1 / (1 + exp(-cbind(1, x) %*% betas))
y <- rbinom(n_data, 1, p)
orig_data <- data.frame(y, x)
counts <-
table(apply(orig_data, 1, function(x)
paste(x, collapse = " ")))
b_hat <- optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = counts)$par[2]
res <- c(res, b_hat)
boot_dist <- foreach(
i = 1:B,
.combine = 'c'
) %dopar% {
ll_fct(
counts, dp = F)
}
boot_dists[[i]] <- boot_dist
dp_counts <- counts + gaussian_mech_zCDP_vec(counts, 1, rho/length(counts))
dp_boot_dist <- foreach(
i = 1:B,
.combine = 'c'
) %dopar% {
ll_fct(
dp_counts, dp = T)
}
#dp_boot_dist <- apply(t(replicate(1000, rowSums(rmultinom(sum(tmp_counts), 1, tmp_counts)))), 1, function(x) optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = x)$par[2])
dp_boot_dists[[i]] <- dp_boot_dist
dp_res <- c(dp_res, optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = dp_counts)$par[2])
cat("Iter: ", i, "\n")
}
pdf(paste0("~/Downloads/logit_cis_n_",n_data,".pdf",
pdf(paste0("~/Downloads/logit_cis_n_",n_data,".pdf"),
width = 11,
height = 8.5)
par(mfrow = c(1, 2))
plot_cis(t(sapply(boot_dists, quantile, c(0.025, 0.975))), true_pop_mean = 1.5, xlim = c(0, 3.5), label = "Bootstrap", xlab = "Logit Coefficient")
plot_cis(t(sapply(dp_boot_dists, quantile, c(0.025, 0.975))), true_pop_mean = 1.5, xlim = c(0, 3.5), label = "DP Bootstrap", xlab = "Logit Coefficient")
dev.off()
n_data <- 5000
dp_res <- NULL
res <- NULL
boot_dists <- list()
dp_boot_dists <- list()
B <- 1000
ll_fct <- function(counts, dp = F){
if(dp){
tmp_counts <- counts + gaussian_mech_zCDP_vec(counts, 1, rho/length(counts))
if (any(tmp_counts < 0)) {
tmp_counts <- tmp_counts + abs(min(tmp_counts[tmp_counts < 0]))
}
} else {
tmp_counts <- counts
}
samp_counts <- rowSums(rmultinom(sum(tmp_counts), 1, tmp_counts))
optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = samp_counts)$par[2]
}
for(i in 1:100){
x <- rbinom(n_data, 1, 0.8)
p <- 1 / (1 + exp(-cbind(1, x) %*% betas))
y <- rbinom(n_data, 1, p)
orig_data <- data.frame(y, x)
counts <-
table(apply(orig_data, 1, function(x)
paste(x, collapse = " ")))
b_hat <- optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = counts)$par[2]
res <- c(res, b_hat)
boot_dist <- foreach(
i = 1:B,
.combine = 'c'
) %dopar% {
ll_fct(
counts, dp = F)
}
boot_dists[[i]] <- boot_dist
dp_counts <- counts + gaussian_mech_zCDP_vec(counts, 1, rho/length(counts))
dp_boot_dist <- foreach(
i = 1:B,
.combine = 'c'
) %dopar% {
ll_fct(
dp_counts, dp = T)
}
#dp_boot_dist <- apply(t(replicate(1000, rowSums(rmultinom(sum(tmp_counts), 1, tmp_counts)))), 1, function(x) optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = x)$par[2])
dp_boot_dists[[i]] <- dp_boot_dist
dp_res <- c(dp_res, optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = dp_counts)$par[2])
cat("Iter: ", i, "\n")
}
pdf(paste0("~/Downloads/logit_cis_n_",n_data,".pdf"),
width = 11,
height = 8.5)
par(mfrow = c(1, 2))
plot_cis(t(sapply(boot_dists, quantile, c(0.025, 0.975))), true_pop_mean = 1.5, xlim = c(0, 3.5), label = "Bootstrap", xlab = "Logit Coefficient")
plot_cis(t(sapply(dp_boot_dists, quantile, c(0.025, 0.975))), true_pop_mean = 1.5, xlim = c(0, 3.5), label = "DP Bootstrap", xlab = "Logit Coefficient")
dev.off()
n_data <- 1000
dp_res <- NULL
res <- NULL
boot_dists <- list()
dp_boot_dists <- list()
B <- 1000
# Set up parallel computing backend
# Detect number of available cores, leave one free
n_cores <- parallel::detectCores() - 1
# Create the cluster
my_cluster <- parallel::makeCluster(n_cores,
type = "FORK")
# Register the cluster to be used by %dopar% for parallelization of for loops
doParallel::registerDoParallel(cl = my_cluster)
# Check if the cluster is registered
foreach::getDoParRegistered()
n_data <- 1000
dp_res <- NULL
res <- NULL
boot_dists <- list()
dp_boot_dists <- list()
B <- 1000
ll_fct <- function(counts, dp = F){
if(dp){
tmp_counts <- counts + gaussian_mech_zCDP_vec(counts, 1, rho/length(counts))
if (any(tmp_counts < 0)) {
tmp_counts <- tmp_counts + abs(min(tmp_counts[tmp_counts < 0]))
}
} else {
tmp_counts <- counts
}
samp_counts <- rowSums(rmultinom(sum(tmp_counts), 1, tmp_counts))
optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = samp_counts)$par[2]
}
for(i in 1:100){
x <- rbinom(n_data, 1, 0.8)
p <- 1 / (1 + exp(-cbind(1, x) %*% betas))
y <- rbinom(n_data, 1, p)
orig_data <- data.frame(y, x)
counts <-
table(apply(orig_data, 1, function(x)
paste(x, collapse = " ")))
b_hat <- optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = counts)$par[2]
res <- c(res, b_hat)
boot_dist <- foreach(
i = 1:B,
.combine = 'c'
) %dopar% {
ll_fct(
counts, dp = F)
}
boot_dists[[i]] <- boot_dist
dp_counts <- counts + gaussian_mech_zCDP_vec(counts, 1, rho/length(counts))
dp_boot_dist <- foreach(
i = 1:B,
.combine = 'c'
) %dopar% {
ll_fct(
dp_counts, dp = T)
}
#dp_boot_dist <- apply(t(replicate(1000, rowSums(rmultinom(sum(tmp_counts), 1, tmp_counts)))), 1, function(x) optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = x)$par[2])
dp_boot_dists[[i]] <- dp_boot_dist
dp_res <- c(dp_res, optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = dp_counts)$par[2])
cat("Iter: ", i, "\n")
}
# Set rho parameter
rho <- 0.00337869
# Check achieved privacy in terms of delta and epsilon
delta <- 1 / (2 * n_data)
epsilon <- rho + 2 * sqrt(rho * log(1 / delta))
pdf(paste0("~/Downloads/logit_cis_n_",n_data,".pdf"),
width = 11,
height = 8.5)
par(mfrow = c(1, 2))
plot_cis(t(sapply(boot_dists, quantile, c(0.025, 0.975))), true_pop_mean = 1.5, xlim = c(0, 3.5), label = "Bootstrap", xlab = "Logit Coefficient")
plot_cis(t(sapply(dp_boot_dists, quantile, c(0.025, 0.975))), true_pop_mean = 1.5, xlim = c(0, 3.5), label = "DP Bootstrap", xlab = "Logit Coefficient")
dev.off()
pdf(paste0("~/Downloads/logit_cis_n_",n_data,".pdf"),
width = 11,
height = 8.5)
par(mfrow = c(1, 2))
plot_cis(t(sapply(boot_dists, quantile, c(0.025, 0.975))), true_pop_mean = 1.5, xlim = c(-2, 5.5), label = "Bootstrap", xlab = "Logit Coefficient")
plot_cis(t(sapply(dp_boot_dists, quantile, c(0.025, 0.975))), true_pop_mean = 1.5, xlim = c(-2, 5.5), label = "DP Bootstrap", xlab = "Logit Coefficient")
dev.off()
# Source other scripts (Assuming the folder with this file is the working directory)
source("00_setup.R")
source("01_functions.R")
# Set up parallel computing backend
# Detect number of available cores, leave one free
n_cores <- parallel::detectCores() - 1
# Create the cluster
my_cluster <- parallel::makeCluster(n_cores,
type = "FORK")
# Register the cluster to be used by %dopar% for parallelization of for loops
doParallel::registerDoParallel(cl = my_cluster)
# Check if the cluster is registered
foreach::getDoParRegistered()
# Set true population parameters for the regression
betas <- c(0, 1.5)
p_x <- 0.8
n_data <- 2000
# Set rho parameter
rho <- 0.00337869
# Check achieved privacy in terms of delta and epsilon
delta <- 1 / (2 * n_data)
epsilon <- rho + 2 * sqrt(rho * log(1 / delta))
dp_res <- NULL
res <- NULL
boot_dists <- list()
dp_boot_dists <- list()
B <- 1000
ll_fct <- function(counts, dp = F){
if(dp){
tmp_counts <- counts + gaussian_mech_zCDP_vec(counts, 1, rho/length(counts))
if (any(tmp_counts < 0)) {
tmp_counts <- tmp_counts + abs(min(tmp_counts[tmp_counts < 0]))
}
} else {
tmp_counts <- counts
}
samp_counts <- rowSums(rmultinom(sum(tmp_counts), 1, tmp_counts))
optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = samp_counts)$par[2]
}
for(i in 1:100){
x <- rbinom(n_data, 1, p_x)
p <- 1 / (1 + exp(-cbind(1, x) %*% betas))
y <- rbinom(n_data, 1, p)
orig_data <- data.frame(y, x)
counts <-
table(apply(orig_data, 1, function(x)
paste(x, collapse = " ")))
b_hat <- optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = counts)$par[2]
res <- c(res, b_hat)
boot_dist <- foreach(
i = 1:B,
.combine = 'c'
) %dopar% {
ll_fct(
counts, dp = F)
}
boot_dists[[i]] <- boot_dist
dp_counts <- counts + gaussian_mech_zCDP_vec(counts, 1, rho/length(counts))
dp_boot_dist <- foreach(
i = 1:B,
.combine = 'c'
) %dopar% {
ll_fct(
dp_counts, dp = T)
}
#dp_boot_dist <- apply(t(replicate(1000, rowSums(rmultinom(sum(tmp_counts), 1, tmp_counts)))), 1, function(x) optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = x)$par[2])
dp_boot_dists[[i]] <- dp_boot_dist
dp_res <- c(dp_res, optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = dp_counts)$par[2])
cat("Iter: ", i, "\n")
}
pdf(paste0("~/Downloads/logit_cis_n_",n_data,".pdf"),
width = 11,
height = 8.5)
par(mfrow = c(1, 2))
plot_cis(t(sapply(boot_dists, quantile, c(0.025, 0.975))), true_pop_mean = 1.5, xlim = c(-2, 5.5), label = "Bootstrap", xlab = "Logit Coefficient")
plot_cis(t(sapply(dp_boot_dists, quantile, c(0.025, 0.975))), true_pop_mean = 1.5, xlim = c(-2, 5.5), label = "DP Bootstrap", xlab = "Logit Coefficient")
dev.off()
dp_res <- NULL
res <- NULL
boot_dists <- list()
dp_boot_dists <- list()
B <- 1000
ll_fct <- function(counts, dp = F){
if(dp){
tmp_counts <- counts + gaussian_mech_zCDP_vec(counts, 1, rho/length(counts))
if (any(tmp_counts < 0)) {
tmp_counts <- tmp_counts + abs(min(tmp_counts[tmp_counts < 0]))
}
} else {
tmp_counts <- counts
}
samp_counts <- rowSums(rmultinom(sum(tmp_counts), 1, tmp_counts))
optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = samp_counts)$par[2]
}
for(i in 1:100){
x <- rbinom(n_data, 1, p_x)
p <- 1 / (1 + exp(-cbind(1, x) %*% betas))
y <- rbinom(n_data, 1, p)
orig_data <- data.frame(y, x)
counts <-
table(apply(orig_data, 1, function(x)
paste(x, collapse = " ")))
b_hat <- optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = counts)$par[2]
res <- c(res, b_hat)
boot_dist <- foreach(
i = 1:B,
.combine = 'c'
) %dopar% {
ll_fct(
counts, dp = F)
}
boot_dists[[i]] <- boot_dist
dp_counts <- counts + gaussian_mech_zCDP_vec(counts, 1, rho/length(counts))
dp_boot_dist <- foreach(
i = 1:B,
.combine = 'c'
) %dopar% {
ll_fct(
dp_counts, dp = T)
}
#dp_boot_dist <- apply(t(replicate(1000, rowSums(rmultinom(sum(tmp_counts), 1, tmp_counts)))), 1, function(x) optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = x)$par[2])
dp_boot_dists[[i]] <- dp_boot_dist
dp_res <- c(dp_res, optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = dp_counts)$par[2])
cat("Iter: ", i, "\n")
}
par(mfrow = c(1, 2))
plot_cis(t(sapply(boot_dists, quantile, c(0.025, 0.975))), true_pop_mean = 1.5, xlim = c(-2, 5.5), label = "Bootstrap", xlab = "Logit Coefficient")
plot_cis(t(sapply(dp_boot_dists, quantile, c(0.025, 0.975))), true_pop_mean = 1.5, xlim = c(-2, 5.5), label = "DP Bootstrap", xlab = "Logit Coefficient")
round(epsilon,2)
n_data <- 2000
# Set rho parameter
rho <- 0.000337869
# Check achieved privacy in terms of delta and epsilon
delta <- 1 / (2 * n_data)
epsilon <- rho + 2 * sqrt(rho * log(1 / delta))
dp_res <- NULL
res <- NULL
boot_dists <- list()
dp_boot_dists <- list()
B <- 1000
ll_fct <- function(counts, dp = F){
if(dp){
tmp_counts <- counts + gaussian_mech_zCDP_vec(counts, 1, rho/length(counts))
if (any(tmp_counts < 0)) {
tmp_counts <- tmp_counts + abs(min(tmp_counts[tmp_counts < 0]))
}
} else {
tmp_counts <- counts
}
samp_counts <- rowSums(rmultinom(sum(tmp_counts), 1, tmp_counts))
optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = samp_counts)$par[2]
}
for(i in 1:100){
x <- rbinom(n_data, 1, p_x)
p <- 1 / (1 + exp(-cbind(1, x) %*% betas))
y <- rbinom(n_data, 1, p)
orig_data <- data.frame(y, x)
counts <-
table(apply(orig_data, 1, function(x)
paste(x, collapse = " ")))
b_hat <- optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = counts)$par[2]
res <- c(res, b_hat)
boot_dist <- foreach(
i = 1:B,
.combine = 'c'
) %dopar% {
ll_fct(
counts, dp = F)
}
boot_dists[[i]] <- boot_dist
dp_counts <- counts + gaussian_mech_zCDP_vec(counts, 1, rho/length(counts))
dp_boot_dist <- foreach(
i = 1:B,
.combine = 'c'
) %dopar% {
ll_fct(
dp_counts, dp = T)
}
#dp_boot_dist <- apply(t(replicate(1000, rowSums(rmultinom(sum(tmp_counts), 1, tmp_counts)))), 1, function(x) optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = x)$par[2])
dp_boot_dists[[i]] <- dp_boot_dist
dp_res <- c(dp_res, optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = dp_counts)$par[2])
cat("Iter: ", i, "\n")
}
par(mfrow = c(1, 2))
plot_cis(t(sapply(boot_dists, quantile, c(0.025, 0.975))), true_pop_mean = 1.5, xlim = c(-2, 5.5), label = "Bootstrap", xlab = "Logit Coefficient")
plot_cis(t(sapply(dp_boot_dists, quantile, c(0.025, 0.975))), true_pop_mean = 1.5, xlim = c(-2, 5.5), label = "DP Bootstrap", xlab = "Logit Coefficient")
plot_cis(t(sapply(dp_boot_dists, quantile, c(0.025, 0.975))), true_pop_mean = 1.5, xlim = c(-20, 25.5), label = "DP Bootstrap", xlab = "Logit Coefficient")
plot_cis(t(sapply(boot_dists, quantile, c(0.025, 0.975))), true_pop_mean = 1.5, xlim = c(-2, 5.5), label = "Bootstrap", xlab = "Logit Coefficient")
plot_cis(t(sapply(dp_boot_dists, quantile, c(0.025, 0.975))), true_pop_mean = 1.5, xlim = c(-20, 25.5), label = "DP Bootstrap", xlab = "Logit Coefficient")
par(mfrow = c(1, 2))
plot_cis(t(sapply(boot_dists, quantile, c(0.025, 0.975))), true_pop_mean = 1.5, xlim = c(-2, 5.5), label = "Bootstrap", xlab = "Logit Coefficient")
plot_cis(t(sapply(dp_boot_dists, quantile, c(0.025, 0.975))), true_pop_mean = 1.5, xlim = c(-20, 25.5), label = "DP Bootstrap", xlab = "Logit Coefficient")
epsilon
rho <- 1
# Check achieved privacy in terms of delta and epsilon
delta <- 1 / (2 * n_data)
epsilon <- rho + 2 * sqrt(rho * log(1 / delta))
dp_res <- NULL
res <- NULL
boot_dists <- list()
dp_boot_dists <- list()
B <- 1000
ll_fct <- function(counts, dp = F){
if(dp){
tmp_counts <- counts + gaussian_mech_zCDP_vec(counts, 1, rho/length(counts))
if (any(tmp_counts < 0)) {
tmp_counts <- tmp_counts + abs(min(tmp_counts[tmp_counts < 0]))
}
} else {
tmp_counts <- counts
}
samp_counts <- rowSums(rmultinom(sum(tmp_counts), 1, tmp_counts))
optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = samp_counts)$par[2]
}
for(i in 1:100){
x <- rbinom(n_data, 1, p_x)
p <- 1 / (1 + exp(-cbind(1, x) %*% betas))
y <- rbinom(n_data, 1, p)
orig_data <- data.frame(y, x)
counts <-
table(apply(orig_data, 1, function(x)
paste(x, collapse = " ")))
b_hat <- optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = counts)$par[2]
res <- c(res, b_hat)
boot_dist <- foreach(
i = 1:B,
.combine = 'c'
) %dopar% {
ll_fct(
counts, dp = F)
}
boot_dists[[i]] <- boot_dist
dp_counts <- counts + gaussian_mech_zCDP_vec(counts, 1, rho/length(counts))
dp_boot_dist <- foreach(
i = 1:B,
.combine = 'c'
) %dopar% {
ll_fct(
dp_counts, dp = T)
}
#dp_boot_dist <- apply(t(replicate(1000, rowSums(rmultinom(sum(tmp_counts), 1, tmp_counts)))), 1, function(x) optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = x)$par[2])
dp_boot_dists[[i]] <- dp_boot_dist
dp_res <- c(dp_res, optim(startval, loglik, X = orig_data$x, y = orig_data$y, counts = dp_counts)$par[2])
cat("Iter: ", i, "\n")
}
